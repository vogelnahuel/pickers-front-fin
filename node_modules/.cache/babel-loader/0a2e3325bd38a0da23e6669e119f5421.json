{"ast":null,"code":"import { __assign, __read, __values } from \"tslib\";\nimport { API } from '@sentry/core';\nimport { Status } from '@sentry/types';\nimport { dateTimestampInSeconds, getGlobalObject, logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport { sendReport } from './utils';\nvar CATEGORY_MAPPING = {\n  event: 'error',\n  transaction: 'transaction',\n  session: 'session',\n  attachment: 'attachment'\n};\nvar global = getGlobalObject();\n/** Base Transport class implementation */\n\nvar BaseTransport =\n/** @class */\nfunction () {\n  function BaseTransport(options) {\n    var _this = this;\n\n    this.options = options;\n    /** A simple buffer holding all requests. */\n\n    this._buffer = new PromiseBuffer(30);\n    /** Locks transport after receiving rate limits in a response */\n\n    this._rateLimits = {};\n    this._outcomes = {};\n    this._api = new API(options.dsn, options._metadata, options.tunnel); // eslint-disable-next-line deprecation/deprecation\n\n    this.url = this._api.getStoreEndpointWithUrlEncodedAuth();\n\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', function () {\n        if (global.document.visibilityState === 'hidden') {\n          _this._flushOutcomes();\n        }\n      });\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.sendEvent = function (_) {\n    throw new SentryError('Transport Class has to implement `sendEvent` method');\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.recordLostEvent = function (reason, category) {\n    var _a;\n\n    if (!this.options.sendClientReports) {\n      return;\n    } // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n\n\n    var key = CATEGORY_MAPPING[category] + \":\" + reason;\n    logger.log(\"Adding outcome: \" + key);\n    this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;\n  };\n  /**\n   * Send outcomes as an envelope\n   */\n\n\n  BaseTransport.prototype._flushOutcomes = function () {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n\n    var outcomes = this._outcomes;\n    this._outcomes = {}; // Nothing to send\n\n    if (!Object.keys(outcomes).length) {\n      logger.log('No outcomes to flush');\n      return;\n    }\n\n    logger.log(\"Flushing outcomes:\\n\" + JSON.stringify(outcomes, null, 2));\n\n    var url = this._api.getEnvelopeEndpointWithUrlEncodedAuth(); // Envelope header is required to be at least an empty object\n\n\n    var envelopeHeader = JSON.stringify(__assign({}, this.options.tunnel && {\n      dsn: this._api.getDsn().toString()\n    }));\n    var itemHeaders = JSON.stringify({\n      type: 'client_report'\n    });\n    var item = JSON.stringify({\n      timestamp: dateTimestampInSeconds(),\n      discarded_events: Object.keys(outcomes).map(function (key) {\n        var _a = __read(key.split(':'), 2),\n            category = _a[0],\n            reason = _a[1];\n\n        return {\n          reason: reason,\n          category: category,\n          quantity: outcomes[key]\n        };\n      })\n    });\n    var envelope = envelopeHeader + \"\\n\" + itemHeaders + \"\\n\" + item;\n\n    try {\n      sendReport(url, envelope);\n    } catch (e) {\n      logger.error(e);\n    }\n  };\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n\n\n  BaseTransport.prototype._handleResponse = function (_a) {\n    var requestType = _a.requestType,\n        response = _a.response,\n        headers = _a.headers,\n        resolve = _a.resolve,\n        reject = _a.reject;\n    var status = Status.fromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n\n    var limited = this._handleRateLimit(headers);\n\n    if (limited) logger.warn(\"Too many \" + requestType + \" requests, backing off until: \" + this._disabledUntil(requestType));\n\n    if (status === Status.Success) {\n      resolve({\n        status: status\n      });\n      return;\n    }\n\n    reject(response);\n  };\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n\n\n  BaseTransport.prototype._disabledUntil = function (requestType) {\n    var category = CATEGORY_MAPPING[requestType];\n    return this._rateLimits[category] || this._rateLimits.all;\n  };\n  /**\n   * Checks if a category is rate limited\n   */\n\n\n  BaseTransport.prototype._isRateLimited = function (requestType) {\n    return this._disabledUntil(requestType) > new Date(Date.now());\n  };\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n\n\n  BaseTransport.prototype._handleRateLimit = function (headers) {\n    var e_1, _a, e_2, _b;\n\n    var now = Date.now();\n    var rlHeader = headers['x-sentry-rate-limits'];\n    var raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      try {\n        // rate limit headers are of the form\n        //     <header>,<header>,..\n        // where each <header> is of the form\n        //     <retry_after>: <categories>: <scope>: <reason_code>\n        // where\n        //     <retry_after> is a delay in ms\n        //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n        //         <category>;<category>;...\n        //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n        //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n        for (var _c = __values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var limit = _d.value;\n          var parameters = limit.split(':', 2);\n          var headerDelay = parseInt(parameters[0], 10);\n          var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n\n          try {\n            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var category = _f.value;\n              this._rateLimits[category || 'all'] = new Date(now + delay);\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n      return true;\n    }\n\n    return false;\n  };\n\n  return BaseTransport;\n}();\n\nexport { BaseTransport };","map":{"version":3,"sources":["../../src/transports/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { API } from '@sentry/core';\nimport {\n  Event,\n  Outcome,\n  Response as SentryResponse,\n  SentryRequestType,\n  Status,\n  Transport,\n  TransportOptions,\n} from '@sentry/types';\nimport {\n  dateTimestampInSeconds,\n  getGlobalObject,\n  logger,\n  parseRetryAfterHeader,\n  PromiseBuffer,\n  SentryError,\n} from '@sentry/utils';\n\nimport { sendReport } from './utils';\n\nconst CATEGORY_MAPPING: {\n  [key in SentryRequestType]: string;\n} = {\n  event: 'error',\n  transaction: 'transaction',\n  session: 'session',\n  attachment: 'attachment',\n};\n\nconst global = getGlobalObject<Window>();\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /**\n   * @deprecated\n   */\n  public url: string;\n\n  /** Helper to get Sentry API endpoints. */\n  protected readonly _api: API;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<SentryResponse> = new PromiseBuffer(30);\n\n  /** Locks transport after receiving rate limits in a response */\n  protected readonly _rateLimits: Record<string, Date> = {};\n\n  protected _outcomes: { [key: string]: number } = {};\n\n  public constructor(public options: TransportOptions) {\n    this._api = new API(options.dsn, options._metadata, options.tunnel);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = this._api.getStoreEndpointWithUrlEncodedAuth();\n\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', () => {\n        if (global.document.visibilityState === 'hidden') {\n          this._flushOutcomes();\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<SentryResponse> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public recordLostEvent(reason: Outcome, category: SentryRequestType): void {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n    const key = `${CATEGORY_MAPPING[category]}:${reason}`;\n    logger.log(`Adding outcome: ${key}`);\n    this._outcomes[key] = (this._outcomes[key] ?? 0) + 1;\n  }\n\n  /**\n   * Send outcomes as an envelope\n   */\n  protected _flushOutcomes(): void {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n\n    // Nothing to send\n    if (!Object.keys(outcomes).length) {\n      logger.log('No outcomes to flush');\n      return;\n    }\n\n    logger.log(`Flushing outcomes:\\n${JSON.stringify(outcomes, null, 2)}`);\n\n    const url = this._api.getEnvelopeEndpointWithUrlEncodedAuth();\n    // Envelope header is required to be at least an empty object\n    const envelopeHeader = JSON.stringify({ ...(this.options.tunnel && { dsn: this._api.getDsn().toString() }) });\n    const itemHeaders = JSON.stringify({\n      type: 'client_report',\n    });\n    const item = JSON.stringify({\n      timestamp: dateTimestampInSeconds(),\n      discarded_events: Object.keys(outcomes).map(key => {\n        const [category, reason] = key.split(':');\n        return {\n          reason,\n          category,\n          quantity: outcomes[key],\n        };\n      }),\n    });\n    const envelope = `${envelopeHeader}\\n${itemHeaders}\\n${item}`;\n\n    try {\n      sendReport(url, envelope);\n    } catch (e) {\n      logger.error(e);\n    }\n  }\n\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  protected _handleResponse({\n    requestType,\n    response,\n    headers,\n    resolve,\n    reject,\n  }: {\n    requestType: SentryRequestType;\n    response: Response | XMLHttpRequest;\n    headers: Record<string, string | null>;\n    resolve: (value?: SentryResponse | PromiseLike<SentryResponse> | null | undefined) => void;\n    reject: (reason?: unknown) => void;\n  }): void {\n    const status = Status.fromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n    const limited = this._handleRateLimit(headers);\n    if (limited)\n      logger.warn(`Too many ${requestType} requests, backing off until: ${this._disabledUntil(requestType)}`);\n\n    if (status === Status.Success) {\n      resolve({ status });\n      return;\n    }\n\n    reject(response);\n  }\n\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n  protected _disabledUntil(requestType: SentryRequestType): Date {\n    const category = CATEGORY_MAPPING[requestType];\n    return this._rateLimits[category] || this._rateLimits.all;\n  }\n\n  /**\n   * Checks if a category is rate limited\n   */\n  protected _isRateLimited(requestType: SentryRequestType): boolean {\n    return this._disabledUntil(requestType) > new Date(Date.now());\n  }\n\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n  protected _handleRateLimit(headers: Record<string, string | null>): boolean {\n    const now = Date.now();\n    const rlHeader = headers['x-sentry-rate-limits'];\n    const raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      // rate limit headers are of the form\n      //     <header>,<header>,..\n      // where each <header> is of the form\n      //     <retry_after>: <categories>: <scope>: <reason_code>\n      // where\n      //     <retry_after> is a delay in ms\n      //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n      //         <category>;<category>;...\n      //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n      //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n      for (const limit of rlHeader.trim().split(',')) {\n        const parameters = limit.split(':', 2);\n        const headerDelay = parseInt(parameters[0], 10);\n        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n        for (const category of parameters[1].split(';')) {\n          this._rateLimits[category || 'all'] = new Date(now + delay);\n        }\n      }\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n      return true;\n    }\n    return false;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}