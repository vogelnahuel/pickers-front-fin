{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { browserPerformanceTimeOrigin, getGlobalObject, htmlTreeAsString, isNodeEnv, logger } from '@sentry/utils';\nimport { msToSec } from '../utils';\nimport { getCLS } from './web-vitals/getCLS';\nimport { getFID } from './web-vitals/getFID';\nimport { getLCP } from './web-vitals/getLCP';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher';\nvar global = getGlobalObject();\n/** Class tracking metrics  */\n\nvar MetricsInstrumentation =\n/** @class */\nfunction () {\n  function MetricsInstrumentation(_reportAllChanges) {\n    if (_reportAllChanges === void 0) {\n      _reportAllChanges = false;\n    }\n\n    var _a, _b;\n\n    this._reportAllChanges = _reportAllChanges;\n    this._measurements = {};\n    this._performanceCursor = 0;\n\n    if (!isNodeEnv() && ((_a = global) === null || _a === void 0 ? void 0 : _a.performance) && ((_b = global) === null || _b === void 0 ? void 0 : _b.document)) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n\n      this._trackCLS();\n\n      this._trackLCP();\n\n      this._trackFID();\n    }\n  }\n  /** Add performance related spans to a transaction */\n\n\n  MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {\n    var _this = this;\n\n    if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n\n    logger.log('[Tracing] Adding & adjusting spans using Performance API');\n    var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n    var entryScriptSrc;\n\n    if (global.document && global.document.scripts) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (var i = 0; i < global.document.scripts.length; i++) {\n        // We go through all scripts on the page and look for 'data-entry'\n        // We remember the name and measure the time between this script finished loading and\n        // our mark 'sentry-tracing-init'\n        if (global.document.scripts[i].dataset.entry === 'true') {\n          entryScriptSrc = global.document.scripts[i].src;\n          break;\n        }\n      }\n    }\n\n    var entryScriptStartTimestamp;\n    var tracingInitMarkStartTime;\n    var responseStartTimestamp;\n    var requestStartTimestamp;\n    global.performance.getEntries().slice(this._performanceCursor).forEach(function (entry) {\n      var startTime = msToSec(entry.startTime);\n      var duration = msToSec(entry.duration);\n\n      if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n        return;\n      }\n\n      switch (entry.entryType) {\n        case 'navigation':\n          {\n            addNavigationSpans(transaction, entry, timeOrigin);\n            responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);\n            requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);\n            break;\n          }\n\n        case 'mark':\n        case 'paint':\n        case 'measure':\n          {\n            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n\n            if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n              tracingInitMarkStartTime = startTimestamp;\n            } // capture web vitals\n\n\n            var firstHidden = getVisibilityWatcher(); // Only report if the page wasn't hidden prior to the web vital.\n\n            var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n            if (entry.name === 'first-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FP');\n              _this._measurements['fp'] = {\n                value: entry.startTime\n              };\n              _this._measurements['mark.fp'] = {\n                value: startTimestamp\n              };\n            }\n\n            if (entry.name === 'first-contentful-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FCP');\n              _this._measurements['fcp'] = {\n                value: entry.startTime\n              };\n              _this._measurements['mark.fcp'] = {\n                value: startTimestamp\n              };\n            }\n\n            break;\n          }\n\n        case 'resource':\n          {\n            var resourceName = entry.name.replace(global.location.origin, '');\n            var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin); // We remember the entry script end time to calculate the difference to the first init mark\n\n            if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n              entryScriptStartTimestamp = endTimestamp;\n            }\n\n            break;\n          }\n\n        default: // Ignore other entry types.\n\n      }\n    });\n\n    if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n      _startChild(transaction, {\n        description: 'evaluation',\n        endTimestamp: tracingInitMarkStartTime,\n        op: 'script',\n        startTimestamp: entryScriptStartTimestamp\n      });\n    }\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n\n    this._trackNavigator(transaction); // Measurements are only available for pageload transactions\n\n\n    if (transaction.op === 'pageload') {\n      // normalize applicable web vital values to be relative to transaction.startTimestamp\n      var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin); // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the\n      // start of the response in milliseconds\n\n      if (typeof responseStartTimestamp === 'number') {\n        logger.log('[Measurements] Adding TTFB');\n        this._measurements['ttfb'] = {\n          value: (responseStartTimestamp - transaction.startTimestamp) * 1000\n        };\n\n        if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {\n          // Capture the time spent making the request and receiving the first byte of the response.\n          // This is the time between the start of the request and the start of the response in milliseconds.\n          this._measurements['ttfb.requestTime'] = {\n            value: (responseStartTimestamp - requestStartTimestamp) * 1000\n          };\n        }\n      }\n\n      ['fcp', 'fp', 'lcp'].forEach(function (name) {\n        if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {\n          return;\n        } // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n        // to be adjusted to be relative to transaction.startTimestamp.\n\n\n        var oldValue = _this._measurements[name].value;\n        var measurementTimestamp = timeOrigin_1 + msToSec(oldValue); // normalizedValue should be in milliseconds\n\n        var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n        var delta = normalizedValue - oldValue;\n        logger.log(\"[Measurements] Normalized \" + name + \" from \" + oldValue + \" to \" + normalizedValue + \" (\" + delta + \")\");\n        _this._measurements[name].value = normalizedValue;\n      });\n\n      if (this._measurements['mark.fid'] && this._measurements['fid']) {\n        // create span for FID\n        _startChild(transaction, {\n          description: 'first input delay',\n          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),\n          op: 'web.vitals',\n          startTimestamp: this._measurements['mark.fid'].value\n        });\n      } // If FCP is not recorded we should not record the cls value\n      // according to the new definition of CLS.\n\n\n      if (!('fcp' in this._measurements)) {\n        delete this._measurements.cls;\n      }\n\n      transaction.setMeasurements(this._measurements);\n\n      this._tagMetricInfo(transaction);\n\n      transaction.setTag('sentry_reportAllChanges', this._reportAllChanges);\n    }\n  };\n  /** Add LCP / CLS data to transaction to allow debugging */\n\n\n  MetricsInstrumentation.prototype._tagMetricInfo = function (transaction) {\n    if (this._lcpEntry) {\n      logger.log('[Measurements] Adding LCP Data'); // Capture Properties of the LCP element that contributes to the LCP.\n\n      if (this._lcpEntry.element) {\n        transaction.setTag('lcp.element', htmlTreeAsString(this._lcpEntry.element));\n      }\n\n      if (this._lcpEntry.id) {\n        transaction.setTag('lcp.id', this._lcpEntry.id);\n      }\n\n      if (this._lcpEntry.url) {\n        // Trim URL to the first 200 characters.\n        transaction.setTag('lcp.url', this._lcpEntry.url.trim().slice(0, 200));\n      }\n\n      transaction.setTag('lcp.size', this._lcpEntry.size);\n    } // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n\n\n    if (this._clsEntry && this._clsEntry.sources) {\n      logger.log('[Measurements] Adding CLS Data');\n\n      this._clsEntry.sources.forEach(function (source, index) {\n        return transaction.setTag(\"cls.source.\" + (index + 1), htmlTreeAsString(source.node));\n      });\n    }\n  };\n  /** Starts tracking the Cumulative Layout Shift on the current page. */\n\n\n  MetricsInstrumentation.prototype._trackCLS = function () {\n    var _this = this; // See:\n    // https://web.dev/evolving-cls/\n    // https://web.dev/cls-web-tooling/\n\n\n    getCLS(function (metric) {\n      var entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      logger.log('[Measurements] Adding CLS');\n      _this._measurements['cls'] = {\n        value: metric.value\n      };\n      _this._clsEntry = entry;\n    });\n  };\n  /**\n   * Capture the information of the user agent.\n   */\n\n\n  MetricsInstrumentation.prototype._trackNavigator = function (transaction) {\n    var navigator = global.navigator;\n\n    if (!navigator) {\n      return;\n    } // track network connectivity\n\n\n    var connection = navigator.connection;\n\n    if (connection) {\n      if (connection.effectiveType) {\n        transaction.setTag('effectiveConnectionType', connection.effectiveType);\n      }\n\n      if (connection.type) {\n        transaction.setTag('connectionType', connection.type);\n      }\n\n      if (isMeasurementValue(connection.rtt)) {\n        this._measurements['connection.rtt'] = {\n          value: connection.rtt\n        };\n      }\n\n      if (isMeasurementValue(connection.downlink)) {\n        this._measurements['connection.downlink'] = {\n          value: connection.downlink\n        };\n      }\n    }\n\n    if (isMeasurementValue(navigator.deviceMemory)) {\n      transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n    }\n\n    if (isMeasurementValue(navigator.hardwareConcurrency)) {\n      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n    }\n  };\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n\n\n  MetricsInstrumentation.prototype._trackLCP = function () {\n    var _this = this;\n\n    getLCP(function (metric) {\n      var entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n      var startTime = msToSec(entry.startTime);\n      logger.log('[Measurements] Adding LCP');\n      _this._measurements['lcp'] = {\n        value: metric.value\n      };\n      _this._measurements['mark.lcp'] = {\n        value: timeOrigin + startTime\n      };\n      _this._lcpEntry = entry;\n    }, this._reportAllChanges);\n  };\n  /** Starts tracking the First Input Delay on the current page. */\n\n\n  MetricsInstrumentation.prototype._trackFID = function () {\n    var _this = this;\n\n    getFID(function (metric) {\n      var entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n      var startTime = msToSec(entry.startTime);\n      logger.log('[Measurements] Adding FID');\n      _this._measurements['fid'] = {\n        value: metric.value\n      };\n      _this._measurements['mark.fid'] = {\n        value: timeOrigin + startTime\n      };\n    });\n  };\n\n  return MetricsInstrumentation;\n}();\n\nexport { MetricsInstrumentation };\n/** Instrument navigation entries */\n\nfunction addNavigationSpans(transaction, entry, timeOrigin) {\n  addPerformanceNavigationTiming({\n    transaction: transaction,\n    entry: entry,\n    event: 'unloadEvent',\n    timeOrigin: timeOrigin\n  });\n  addPerformanceNavigationTiming({\n    transaction: transaction,\n    entry: entry,\n    event: 'redirect',\n    timeOrigin: timeOrigin\n  });\n  addPerformanceNavigationTiming({\n    transaction: transaction,\n    entry: entry,\n    event: 'domContentLoadedEvent',\n    timeOrigin: timeOrigin\n  });\n  addPerformanceNavigationTiming({\n    transaction: transaction,\n    entry: entry,\n    event: 'loadEvent',\n    timeOrigin: timeOrigin\n  });\n  addPerformanceNavigationTiming({\n    transaction: transaction,\n    entry: entry,\n    event: 'connect',\n    timeOrigin: timeOrigin\n  });\n  addPerformanceNavigationTiming({\n    transaction: transaction,\n    entry: entry,\n    event: 'secureConnection',\n    timeOrigin: timeOrigin,\n    eventEnd: 'connectEnd',\n    description: 'TLS/SSL'\n  });\n  addPerformanceNavigationTiming({\n    transaction: transaction,\n    entry: entry,\n    event: 'fetch',\n    timeOrigin: timeOrigin,\n    eventEnd: 'domainLookupStart',\n    description: 'cache'\n  });\n  addPerformanceNavigationTiming({\n    transaction: transaction,\n    entry: entry,\n    event: 'domainLookup',\n    timeOrigin: timeOrigin,\n    description: 'DNS'\n  });\n  addRequest(transaction, entry, timeOrigin);\n}\n/** Create measure related spans */\n\n\nfunction addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {\n  var measureStartTimestamp = timeOrigin + startTime;\n  var measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType,\n    startTimestamp: measureStartTimestamp\n  });\n\n  return measureStartTimestamp;\n}\n/** Create resource-related spans */\n\n\nexport function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return undefined;\n  }\n\n  var data = {};\n\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  var startTimestamp = timeOrigin + startTime;\n  var endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp: endTimestamp,\n    op: entry.initiatorType ? \"resource.\" + entry.initiatorType : 'resource',\n    startTimestamp: startTimestamp,\n    data: data\n  });\n\n  return endTimestamp;\n}\n/** Create performance navigation related spans */\n\nfunction addPerformanceNavigationTiming(props) {\n  var transaction = props.transaction,\n      entry = props.entry,\n      event = props.event,\n      timeOrigin = props.timeOrigin,\n      eventEnd = props.eventEnd,\n      description = props.description;\n  var end = eventEnd ? entry[eventEnd] : entry[event + \"End\"];\n  var start = entry[event + \"Start\"];\n\n  if (!start || !end) {\n    return;\n  }\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: description !== null && description !== void 0 ? description : event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end)\n  });\n}\n/** Create request and response related spans */\n\n\nfunction addRequest(transaction, entry, timeOrigin) {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd)\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd)\n  });\n}\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\n\n\nexport function _startChild(transaction, _a) {\n  var startTimestamp = _a.startTimestamp,\n      ctx = __rest(_a, [\"startTimestamp\"]);\n\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild(__assign({\n    startTimestamp: startTimestamp\n  }, ctx));\n}\n/**\n * Checks if a given value is a valid measurement value.\n */\n\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}","map":{"version":3,"sources":["../../src/browser/metrics.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Measurements, SpanContext } from '@sentry/types';\nimport { browserPerformanceTimeOrigin, getGlobalObject, htmlTreeAsString, isNodeEnv, logger } from '@sentry/utils';\n\nimport { Span } from '../span';\nimport { Transaction } from '../transaction';\nimport { msToSec } from '../utils';\nimport { getCLS, LayoutShift } from './web-vitals/getCLS';\nimport { getFID } from './web-vitals/getFID';\nimport { getLCP, LargestContentfulPaint } from './web-vitals/getLCP';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher';\nimport { NavigatorDeviceMemory, NavigatorNetworkInformation } from './web-vitals/types';\n\nconst global = getGlobalObject<Window>();\n\n/** Class tracking metrics  */\nexport class MetricsInstrumentation {\n  private _measurements: Measurements = {};\n\n  private _performanceCursor: number = 0;\n  private _lcpEntry: LargestContentfulPaint | undefined;\n  private _clsEntry: LayoutShift | undefined;\n\n  public constructor(private _reportAllChanges: boolean = false) {\n    if (!isNodeEnv() && global?.performance && global?.document) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n\n      this._trackCLS();\n      this._trackLCP();\n      this._trackFID();\n    }\n  }\n\n  /** Add performance related spans to a transaction */\n  public addPerformanceEntries(transaction: Transaction): void {\n    if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n\n    logger.log('[Tracing] Adding & adjusting spans using Performance API');\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n    let entryScriptSrc: string | undefined;\n\n    if (global.document && global.document.scripts) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < global.document.scripts.length; i++) {\n        // We go through all scripts on the page and look for 'data-entry'\n        // We remember the name and measure the time between this script finished loading and\n        // our mark 'sentry-tracing-init'\n        if (global.document.scripts[i].dataset.entry === 'true') {\n          entryScriptSrc = global.document.scripts[i].src;\n          break;\n        }\n      }\n    }\n\n    let entryScriptStartTimestamp: number | undefined;\n    let tracingInitMarkStartTime: number | undefined;\n    let responseStartTimestamp: number | undefined;\n    let requestStartTimestamp: number | undefined;\n\n    global.performance\n      .getEntries()\n      .slice(this._performanceCursor)\n      .forEach((entry: Record<string, any>) => {\n        const startTime = msToSec(entry.startTime as number);\n        const duration = msToSec(entry.duration as number);\n\n        if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n          return;\n        }\n\n        switch (entry.entryType) {\n          case 'navigation': {\n            addNavigationSpans(transaction, entry, timeOrigin);\n            responseStartTimestamp = timeOrigin + msToSec(entry.responseStart as number);\n            requestStartTimestamp = timeOrigin + msToSec(entry.requestStart as number);\n            break;\n          }\n          case 'mark':\n          case 'paint':\n          case 'measure': {\n            const startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n            if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n              tracingInitMarkStartTime = startTimestamp;\n            }\n\n            // capture web vitals\n\n            const firstHidden = getVisibilityWatcher();\n            // Only report if the page wasn't hidden prior to the web vital.\n            const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n            if (entry.name === 'first-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FP');\n              this._measurements['fp'] = { value: entry.startTime };\n              this._measurements['mark.fp'] = { value: startTimestamp };\n            }\n\n            if (entry.name === 'first-contentful-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FCP');\n              this._measurements['fcp'] = { value: entry.startTime };\n              this._measurements['mark.fcp'] = { value: startTimestamp };\n            }\n\n            break;\n          }\n          case 'resource': {\n            const resourceName = (entry.name as string).replace(global.location.origin, '');\n            const endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n            // We remember the entry script end time to calculate the difference to the first init mark\n            if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n              entryScriptStartTimestamp = endTimestamp;\n            }\n            break;\n          }\n          default:\n          // Ignore other entry types.\n        }\n      });\n\n    if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n      _startChild(transaction, {\n        description: 'evaluation',\n        endTimestamp: tracingInitMarkStartTime,\n        op: 'script',\n        startTimestamp: entryScriptStartTimestamp,\n      });\n    }\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n\n    this._trackNavigator(transaction);\n\n    // Measurements are only available for pageload transactions\n    if (transaction.op === 'pageload') {\n      // normalize applicable web vital values to be relative to transaction.startTimestamp\n\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n\n      // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the\n      // start of the response in milliseconds\n      if (typeof responseStartTimestamp === 'number') {\n        logger.log('[Measurements] Adding TTFB');\n        this._measurements['ttfb'] = { value: (responseStartTimestamp - transaction.startTimestamp) * 1000 };\n\n        if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {\n          // Capture the time spent making the request and receiving the first byte of the response.\n          // This is the time between the start of the request and the start of the response in milliseconds.\n          this._measurements['ttfb.requestTime'] = { value: (responseStartTimestamp - requestStartTimestamp) * 1000 };\n        }\n      }\n\n      ['fcp', 'fp', 'lcp'].forEach(name => {\n        if (!this._measurements[name] || timeOrigin >= transaction.startTimestamp) {\n          return;\n        }\n\n        // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n        // to be adjusted to be relative to transaction.startTimestamp.\n\n        const oldValue = this._measurements[name].value;\n        const measurementTimestamp = timeOrigin + msToSec(oldValue);\n        // normalizedValue should be in milliseconds\n        const normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n\n        const delta = normalizedValue - oldValue;\n        logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);\n\n        this._measurements[name].value = normalizedValue;\n      });\n\n      if (this._measurements['mark.fid'] && this._measurements['fid']) {\n        // create span for FID\n\n        _startChild(transaction, {\n          description: 'first input delay',\n          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),\n          op: 'web.vitals',\n          startTimestamp: this._measurements['mark.fid'].value,\n        });\n      }\n\n      // If FCP is not recorded we should not record the cls value\n      // according to the new definition of CLS.\n      if (!('fcp' in this._measurements)) {\n        delete this._measurements.cls;\n      }\n\n      transaction.setMeasurements(this._measurements);\n      this._tagMetricInfo(transaction);\n\n      transaction.setTag('sentry_reportAllChanges', this._reportAllChanges);\n    }\n  }\n\n  /** Add LCP / CLS data to transaction to allow debugging */\n  private _tagMetricInfo(transaction: Transaction): void {\n    if (this._lcpEntry) {\n      logger.log('[Measurements] Adding LCP Data');\n      // Capture Properties of the LCP element that contributes to the LCP.\n\n      if (this._lcpEntry.element) {\n        transaction.setTag('lcp.element', htmlTreeAsString(this._lcpEntry.element));\n      }\n\n      if (this._lcpEntry.id) {\n        transaction.setTag('lcp.id', this._lcpEntry.id);\n      }\n\n      if (this._lcpEntry.url) {\n        // Trim URL to the first 200 characters.\n        transaction.setTag('lcp.url', this._lcpEntry.url.trim().slice(0, 200));\n      }\n\n      transaction.setTag('lcp.size', this._lcpEntry.size);\n    }\n\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n    if (this._clsEntry && this._clsEntry.sources) {\n      logger.log('[Measurements] Adding CLS Data');\n      this._clsEntry.sources.forEach((source, index) =>\n        transaction.setTag(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n      );\n    }\n  }\n\n  /** Starts tracking the Cumulative Layout Shift on the current page. */\n  private _trackCLS(): void {\n    // See:\n    // https://web.dev/evolving-cls/\n    // https://web.dev/cls-web-tooling/\n    getCLS(metric => {\n      const entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n\n      logger.log('[Measurements] Adding CLS');\n      this._measurements['cls'] = { value: metric.value };\n      this._clsEntry = entry as LayoutShift;\n    });\n  }\n\n  /**\n   * Capture the information of the user agent.\n   */\n  private _trackNavigator(transaction: Transaction): void {\n    const navigator = global.navigator as null | (Navigator & NavigatorNetworkInformation & NavigatorDeviceMemory);\n    if (!navigator) {\n      return;\n    }\n\n    // track network connectivity\n    const connection = navigator.connection;\n    if (connection) {\n      if (connection.effectiveType) {\n        transaction.setTag('effectiveConnectionType', connection.effectiveType);\n      }\n\n      if (connection.type) {\n        transaction.setTag('connectionType', connection.type);\n      }\n\n      if (isMeasurementValue(connection.rtt)) {\n        this._measurements['connection.rtt'] = { value: connection.rtt as number };\n      }\n\n      if (isMeasurementValue(connection.downlink)) {\n        this._measurements['connection.downlink'] = { value: connection.downlink as number };\n      }\n    }\n\n    if (isMeasurementValue(navigator.deviceMemory)) {\n      transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n    }\n\n    if (isMeasurementValue(navigator.hardwareConcurrency)) {\n      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n    }\n  }\n\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n  private _trackLCP(): void {\n    getLCP(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin as number);\n      const startTime = msToSec(entry.startTime as number);\n      logger.log('[Measurements] Adding LCP');\n      this._measurements['lcp'] = { value: metric.value };\n      this._measurements['mark.lcp'] = { value: timeOrigin + startTime };\n      this._lcpEntry = entry as LargestContentfulPaint;\n    }, this._reportAllChanges);\n  }\n\n  /** Starts tracking the First Input Delay on the current page. */\n  private _trackFID(): void {\n    getFID(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin as number);\n      const startTime = msToSec(entry.startTime as number);\n      logger.log('[Measurements] Adding FID');\n      this._measurements['fid'] = { value: metric.value };\n      this._measurements['mark.fid'] = { value: timeOrigin + startTime };\n    });\n  }\n}\n\n/** Instrument navigation entries */\nfunction addNavigationSpans(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  addPerformanceNavigationTiming({ transaction, entry, event: 'unloadEvent', timeOrigin });\n  addPerformanceNavigationTiming({ transaction, entry, event: 'redirect', timeOrigin });\n  addPerformanceNavigationTiming({ transaction, entry, event: 'domContentLoadedEvent', timeOrigin });\n  addPerformanceNavigationTiming({ transaction, entry, event: 'loadEvent', timeOrigin });\n  addPerformanceNavigationTiming({ transaction, entry, event: 'connect', timeOrigin });\n  addPerformanceNavigationTiming({\n    transaction,\n    entry,\n    event: 'secureConnection',\n    timeOrigin,\n    eventEnd: 'connectEnd',\n    description: 'TLS/SSL',\n  });\n  addPerformanceNavigationTiming({\n    transaction,\n    entry,\n    event: 'fetch',\n    timeOrigin,\n    eventEnd: 'domainLookupStart',\n    description: 'cache',\n  });\n  addPerformanceNavigationTiming({ transaction, entry, event: 'domainLookup', timeOrigin, description: 'DNS' });\n  addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create measure related spans */\nfunction addMeasureSpans(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number {\n  const measureStartTimestamp = timeOrigin + startTime;\n  const measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name as string,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType as string,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\nexport interface ResourceEntry extends Record<string, unknown> {\n  initiatorType?: string;\n  transferSize?: number;\n  encodedBodySize?: number;\n  decodedBodySize?: number;\n}\n\n/** Create resource-related spans */\nexport function addResourceSpans(\n  transaction: Transaction,\n  entry: ResourceEntry,\n  resourceName: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number | undefined {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return undefined;\n  }\n\n  const data: Record<string, any> = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource',\n    startTimestamp,\n    data,\n  });\n\n  return endTimestamp;\n}\n\n/** Create performance navigation related spans */\nfunction addPerformanceNavigationTiming(props: {\n  transaction: Transaction;\n  entry: Record<string, any>;\n  event: string;\n  timeOrigin: number;\n  eventEnd?: string;\n  description?: string;\n}): void {\n  const { transaction, entry, event, timeOrigin, eventEnd, description } = props;\n\n  const end = eventEnd ? (entry[eventEnd] as number | undefined) : (entry[`${event}End`] as number | undefined);\n  const start = entry[`${event}Start`] as number | undefined;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: description ?? event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end),\n  });\n}\n\n/** Create request and response related spans */\nfunction addRequest(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function _startChild(transaction: Transaction, { startTimestamp, ...ctx }: SpanContext): Span {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value: any): boolean {\n  return typeof value === 'number' && isFinite(value);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}