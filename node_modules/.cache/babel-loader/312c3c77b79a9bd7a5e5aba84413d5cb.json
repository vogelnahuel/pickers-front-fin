{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { logger } from '@sentry/utils';\nexport var installedIntegrations = [];\n/**\n * @private\n */\n\nfunction filterDuplicates(integrations) {\n  return integrations.reduce(function (acc, integrations) {\n    if (acc.every(function (accIntegration) {\n      return integrations.name !== accIntegration.name;\n    })) {\n      acc.push(integrations);\n    }\n\n    return acc;\n  }, []);\n}\n/** Gets integration to install */\n\n\nexport function getIntegrationsToSetup(options) {\n  var defaultIntegrations = options.defaultIntegrations && __spread(options.defaultIntegrations) || [];\n  var userIntegrations = options.integrations;\n\n  var integrations = __spread(filterDuplicates(defaultIntegrations));\n\n  if (Array.isArray(userIntegrations)) {\n    // Filter out integrations that are also included in user options\n    integrations = __spread(integrations.filter(function (integrations) {\n      return userIntegrations.every(function (userIntegration) {\n        return userIntegration.name !== integrations.name;\n      });\n    }), filterDuplicates(userIntegrations));\n  } else if (typeof userIntegrations === 'function') {\n    integrations = userIntegrations(integrations);\n    integrations = Array.isArray(integrations) ? integrations : [integrations];\n  } // Make sure that if present, `Debug` integration will always run last\n\n\n  var integrationsNames = integrations.map(function (i) {\n    return i.name;\n  });\n  var alwaysLastToRun = 'Debug';\n\n  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {\n    integrations.push.apply(integrations, __spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));\n  }\n\n  return integrations;\n}\n/** Setup given integration */\n\nexport function setupIntegration(integration) {\n  if (installedIntegrations.indexOf(integration.name) !== -1) {\n    return;\n  }\n\n  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n  installedIntegrations.push(integration.name);\n  logger.log(\"Integration installed: \" + integration.name);\n}\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\n\nexport function setupIntegrations(options) {\n  var integrations = {};\n  getIntegrationsToSetup(options).forEach(function (integration) {\n    integrations[integration.name] = integration;\n    setupIntegration(integration);\n  }); // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`\n  // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be\n  // considered a member of the index the way the actual integrations are\n\n  Object.defineProperty(integrations, 'initialized', {\n    value: true\n  });\n  return integrations;\n}","map":{"version":3,"sources":["../src/integration.ts"],"names":[],"mappings":"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","sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { Integration, Options } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n} & { initialized?: boolean };\n\n/**\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  return integrations.reduce((acc, integrations) => {\n    if (acc.every(accIntegration => integrations.name !== accIntegration.name)) {\n      acc.push(integrations);\n    }\n    return acc;\n  }, [] as Integration[]);\n}\n\n/** Gets integration to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = (options.defaultIntegrations && [...options.defaultIntegrations]) || [];\n  const userIntegrations = options.integrations;\n\n  let integrations: Integration[] = [...filterDuplicates(defaultIntegrations)];\n\n  if (Array.isArray(userIntegrations)) {\n    // Filter out integrations that are also included in user options\n    integrations = [\n      ...integrations.filter(integrations =>\n        userIntegrations.every(userIntegration => userIntegration.name !== integrations.name),\n      ),\n      // And filter out duplicated user options integrations\n      ...filterDuplicates(userIntegrations),\n    ];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = userIntegrations(integrations);\n    integrations = Array.isArray(integrations) ? integrations : [integrations];\n  }\n\n  // Make sure that if present, `Debug` integration will always run last\n  const integrationsNames = integrations.map(i => i.name);\n  const alwaysLastToRun = 'Debug';\n  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {\n    integrations.push(...integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1));\n  }\n\n  return integrations;\n}\n\n/** Setup given integration */\nexport function setupIntegration(integration: Integration): void {\n  if (installedIntegrations.indexOf(integration.name) !== -1) {\n    return;\n  }\n  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n  installedIntegrations.push(integration.name);\n  logger.log(`Integration installed: ${integration.name}`);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations<O extends Options>(options: O): IntegrationIndex {\n  const integrations: IntegrationIndex = {};\n  getIntegrationsToSetup(options).forEach(integration => {\n    integrations[integration.name] = integration;\n    setupIntegration(integration);\n  });\n  // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`\n  // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be\n  // considered a member of the index the way the actual integrations are\n  Object.defineProperty(integrations, 'initialized', { value: true });\n  return integrations;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}