{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\nvar OPERATIONS = ['aggregate', 'bulkWrite', 'countDocuments', 'createIndex', 'createIndexes', 'deleteMany', 'deleteOne', 'distinct', 'drop', 'dropIndex', 'dropIndexes', 'estimatedDocumentCount', 'find', 'findOne', 'findOneAndDelete', 'findOneAndReplace', 'findOneAndUpdate', 'indexes', 'indexExists', 'indexInformation', 'initializeOrderedBulkOp', 'insertMany', 'insertOne', 'isCapped', 'mapReduce', 'options', 'parallelCollectionScan', 'rename', 'replaceOne', 'stats', 'updateMany', 'updateOne']; // All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\n\nvar OPERATION_SIGNATURES = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update']\n};\n/** Tracing integration for mongo package */\n\nvar Mongo =\n/** @class */\nfunction () {\n  /**\n   * @inheritDoc\n   */\n  function Mongo(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    /**\n     * @inheritDoc\n     */\n\n\n    this.name = Mongo.id;\n    this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  Mongo.prototype.setupOnce = function (_, getCurrentHub) {\n    var moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    var pkg = loadModule(moduleName);\n\n    if (!pkg) {\n      logger.error(\"Mongo Integration was unable to require `\" + moduleName + \"` package.\");\n      return;\n    }\n\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  };\n  /**\n   * Patches original collection methods\n   */\n\n\n  Mongo.prototype._instrumentOperations = function (collection, operations, getCurrentHub) {\n    var _this = this;\n\n    operations.forEach(function (operation) {\n      return _this._patchOperation(collection, operation, getCurrentHub);\n    });\n  };\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n\n\n  Mongo.prototype._patchOperation = function (collection, operation, getCurrentHub) {\n    if (!(operation in collection.prototype)) return;\n\n    var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n\n    fill(collection.prototype, operation, function (orig) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var _a, _b, _c, _d;\n\n        var lastArg = args[args.length - 1];\n        var scope = getCurrentHub().getScope();\n        var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan(); // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n\n        if (typeof lastArg !== 'function' || operation === 'mapReduce' && args.length === 2) {\n          var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args));\n          var maybePromise = orig.call.apply(orig, __spread([this], args));\n\n          if (isThenable(maybePromise)) {\n            return maybePromise.then(function (res) {\n              var _a;\n\n              (_a = span_1) === null || _a === void 0 ? void 0 : _a.finish();\n              return res;\n            });\n          } else {\n            (_c = span_1) === null || _c === void 0 ? void 0 : _c.finish();\n            return maybePromise;\n          }\n        }\n\n        var span = (_d = parentSpan) === null || _d === void 0 ? void 0 : _d.startChild(getSpanContext(this, operation, args.slice(0, -1)));\n        return orig.call.apply(orig, __spread([this], args.slice(0, -1), [function (err, result) {\n          var _a;\n\n          (_a = span) === null || _a === void 0 ? void 0 : _a.finish();\n          lastArg(err, result);\n        }]));\n      };\n    });\n  };\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n\n\n  Mongo.prototype._getSpanContextFromOperationArguments = function (collection, operation, args) {\n    var data = {\n      collectionName: collection.collectionName,\n      dbName: collection.dbName,\n      namespace: collection.namespace\n    };\n    var spanContext = {\n      op: \"db\",\n      description: operation,\n      data: data\n    }; // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n\n    var signature = OPERATION_SIGNATURES[operation];\n    var shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;\n\n    if (!signature || !shouldDescribe) {\n      return spanContext;\n    }\n\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        var _a = __read(args, 2),\n            map = _a[0],\n            reduce = _a[1];\n\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (var i = 0; i < signature.length; i++) {\n          data[signature[i]] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {// no-empty\n    }\n\n    return spanContext;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Mongo.id = 'Mongo';\n  return Mongo;\n}();\n\nexport { Mongo };","map":{"version":3,"sources":["../../../src/integrations/node/mongo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Hub } from '@sentry/hub';\nimport { EventProcessor, Integration, SpanContext } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\n// This allows us to use the same array for both defaults options and the type itself.\n// (note `as const` at the end to make it a union of string literal types (i.e. \"a\" | \"b\" | ... )\n// and not just a string[])\ntype Operation = typeof OPERATIONS[number];\nconst OPERATIONS = [\n  'aggregate', // aggregate(pipeline, options, callback)\n  'bulkWrite', // bulkWrite(operations, options, callback)\n  'countDocuments', // countDocuments(query, options, callback)\n  'createIndex', // createIndex(fieldOrSpec, options, callback)\n  'createIndexes', // createIndexes(indexSpecs, options, callback)\n  'deleteMany', // deleteMany(filter, options, callback)\n  'deleteOne', // deleteOne(filter, options, callback)\n  'distinct', // distinct(key, query, options, callback)\n  'drop', // drop(options, callback)\n  'dropIndex', // dropIndex(indexName, options, callback)\n  'dropIndexes', // dropIndexes(options, callback)\n  'estimatedDocumentCount', // estimatedDocumentCount(options, callback)\n  'find', // find(query, options, callback)\n  'findOne', // findOne(query, options, callback)\n  'findOneAndDelete', // findOneAndDelete(filter, options, callback)\n  'findOneAndReplace', // findOneAndReplace(filter, replacement, options, callback)\n  'findOneAndUpdate', // findOneAndUpdate(filter, update, options, callback)\n  'indexes', // indexes(options, callback)\n  'indexExists', // indexExists(indexes, options, callback)\n  'indexInformation', // indexInformation(options, callback)\n  'initializeOrderedBulkOp', // initializeOrderedBulkOp(options, callback)\n  'insertMany', // insertMany(docs, options, callback)\n  'insertOne', // insertOne(doc, options, callback)\n  'isCapped', // isCapped(options, callback)\n  'mapReduce', // mapReduce(map, reduce, options, callback)\n  'options', // options(options, callback)\n  'parallelCollectionScan', // parallelCollectionScan(options, callback)\n  'rename', // rename(newName, options, callback)\n  'replaceOne', // replaceOne(filter, doc, options, callback)\n  'stats', // stats(options, callback)\n  'updateMany', // updateMany(filter, update, options, callback)\n  'updateOne', // updateOne(filter, update, options, callback)\n] as const;\n\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nconst OPERATION_SIGNATURES: {\n  [op in Operation]?: string[];\n} = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update'],\n};\n\ninterface MongoCollection {\n  collectionName: string;\n  dbName: string;\n  namespace: string;\n  prototype: {\n    [operation in Operation]: (...args: unknown[]) => unknown;\n  };\n}\n\ninterface MongoOptions {\n  operations?: Operation[];\n  describeOperations?: boolean | Operation[];\n  useMongoose?: boolean;\n}\n\n/** Tracing integration for mongo package */\nexport class Mongo implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Mongo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Mongo.id;\n\n  private _operations: Operation[];\n  private _describeOperations?: boolean | Operation[];\n  private _useMongoose: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: MongoOptions = {}) {\n    this._operations = Array.isArray(options.operations)\n      ? options.operations\n      : ((OPERATIONS as unknown) as Operation[]);\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    const pkg = loadModule<{ Collection: MongoCollection }>(moduleName);\n\n    if (!pkg) {\n      logger.error(`Mongo Integration was unable to require \\`${moduleName}\\` package.`);\n      return;\n    }\n\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  }\n\n  /**\n   * Patches original collection methods\n   */\n  private _instrumentOperations(collection: MongoCollection, operations: Operation[], getCurrentHub: () => Hub): void {\n    operations.forEach((operation: Operation) => this._patchOperation(collection, operation, getCurrentHub));\n  }\n\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  private _patchOperation(collection: MongoCollection, operation: Operation, getCurrentHub: () => Hub): void {\n    if (!(operation in collection.prototype)) return;\n\n    const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n\n    fill(collection.prototype, operation, function(orig: () => void | Promise<unknown>) {\n      return function(this: unknown, ...args: unknown[]) {\n        const lastArg = args[args.length - 1];\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {\n          const span = parentSpan?.startChild(getSpanContext(this, operation, args));\n          const maybePromise = orig.call(this, ...args) as Promise<unknown>;\n\n          if (isThenable(maybePromise)) {\n            return maybePromise.then((res: unknown) => {\n              span?.finish();\n              return res;\n            });\n          } else {\n            span?.finish();\n            return maybePromise;\n          }\n        }\n\n        const span = parentSpan?.startChild(getSpanContext(this, operation, args.slice(0, -1)));\n        return orig.call(this, ...args.slice(0, -1), function(err: Error, result: unknown) {\n          span?.finish();\n          lastArg(err, result);\n        });\n      };\n    });\n  }\n\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  private _getSpanContextFromOperationArguments(\n    collection: MongoCollection,\n    operation: Operation,\n    args: unknown[],\n  ): SpanContext {\n    const data: { [key: string]: string } = {\n      collectionName: collection.collectionName,\n      dbName: collection.dbName,\n      namespace: collection.namespace,\n    };\n    const spanContext: SpanContext = {\n      op: `db`,\n      description: operation,\n      data,\n    };\n\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    const signature = OPERATION_SIGNATURES[operation];\n    const shouldDescribe = Array.isArray(this._describeOperations)\n      ? this._describeOperations.includes(operation)\n      : this._describeOperations;\n\n    if (!signature || !shouldDescribe) {\n      return spanContext;\n    }\n\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        const [map, reduce] = args as { name?: string }[];\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (let i = 0; i < signature.length; i++) {\n          data[signature[i]] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n\n    return spanContext;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}