{"ast":null,"code":"import { forget, getGlobalObject, isNativeFetch, logger, supportsFetch } from '@sentry/utils';\nvar global = getGlobalObject();\nvar cachedFetchImpl;\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\n\nexport function getNativeFetchImplementation() {\n  var _a, _b;\n\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n  /* eslint-disable @typescript-eslint/unbound-method */\n  // Fast path to avoid DOM I/O\n\n\n  if (isNativeFetch(global.fetch)) {\n    return cachedFetchImpl = global.fetch.bind(global);\n  }\n\n  var document = global.document;\n  var fetchImpl = global.fetch; // eslint-disable-next-line deprecation/deprecation\n\n  if (typeof ((_a = document) === null || _a === void 0 ? void 0 : _a.createElement) === \"function\") {\n    try {\n      var sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n\n      if ((_b = sandbox.contentWindow) === null || _b === void 0 ? void 0 : _b.fetch) {\n        fetchImpl = sandbox.contentWindow.fetch;\n      }\n\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return cachedFetchImpl = fetchImpl.bind(global);\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n/**\n * Sends sdk client report using sendBeacon or fetch as a fallback if available\n *\n * @param url report endpoint\n * @param body report payload\n */\n\nexport function sendReport(url, body) {\n  var isRealNavigator = Object.prototype.toString.call(global && global.navigator) === '[object Navigator]';\n  var hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === 'function';\n\n  if (hasSendBeacon) {\n    // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch\n    var sendBeacon = global.navigator.sendBeacon.bind(global.navigator);\n    return sendBeacon(url, body);\n  }\n\n  if (supportsFetch()) {\n    var fetch_1 = getNativeFetchImplementation();\n    return forget(fetch_1(url, {\n      body: body,\n      method: 'POST',\n      credentials: 'omit',\n      keepalive: true\n    }));\n  }\n}","map":{"version":3,"sources":["../../src/transports/utils.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,EAAiB,eAAjB,EAAkC,aAAlC,EAAiD,MAAjD,EAAyD,aAAzD,QAA8E,eAA9E;AAEA,IAAM,MAAM,GAAG,eAAe,EAA9B;AACA,IAAI,eAAJ;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCG;;AACH,OAAM,SAAU,4BAAV,GAAsC;;;AAC1C,MAAI,eAAJ,EAAqB;AACnB,WAAO,eAAP;AACD;AAED;AAEA;;;AACA,MAAI,aAAa,CAAC,MAAM,CAAC,KAAR,CAAjB,EAAiC;AAC/B,WAAQ,eAAe,GAAG,MAAM,CAAC,KAAP,CAAa,IAAb,CAAkB,MAAlB,CAA1B;AACD;;AAED,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAxB;AACA,MAAI,SAAS,GAAG,MAAM,CAAC,KAAvB,CAb0C,CAc1C;;AACA,MAAI,QAAA,CAAA,EAAA,GAAO,QAAP,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,aAAjB,MAAmC,UAAvC,EAAmD;AACjD,QAAI;AACF,UAAM,OAAO,GAAG,QAAQ,CAAC,aAAT,CAAuB,QAAvB,CAAhB;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,IAAjB;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,OAA1B;;AACA,UAAA,CAAA,EAAA,GAAI,OAAO,CAAC,aAAZ,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,KAAA,CAAzB,GAAyB,EAAA,CAAE,KAA3B,EAAkC;AAChC,QAAA,SAAS,GAAG,OAAO,CAAC,aAAR,CAAsB,KAAlC;AACD;;AACD,MAAA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,OAA1B;AACD,KARD,CAQE,OAAO,CAAP,EAAU;AACV,MAAA,MAAM,CAAC,IAAP,CAAY,iFAAZ,EAA+F,CAA/F;AACD;AACF;;AAED,SAAQ,eAAe,GAAG,SAAS,CAAC,IAAV,CAAe,MAAf,CAA1B;AACA;AACD;AAED;;;;;AAKG;;AACH,OAAM,SAAU,UAAV,CAAqB,GAArB,EAAkC,IAAlC,EAA8C;AAClD,MAAM,eAAe,GAAG,MAAM,CAAC,SAAP,CAAiB,QAAjB,CAA0B,IAA1B,CAA+B,MAAM,IAAI,MAAM,CAAC,SAAhD,MAA+D,oBAAvF;AACA,MAAM,aAAa,GAAG,eAAe,IAAI,OAAO,MAAM,CAAC,SAAP,CAAiB,UAAxB,KAAuC,UAAhF;;AAEA,MAAI,aAAJ,EAAmB;AACjB;AACA,QAAM,UAAU,GAAG,MAAM,CAAC,SAAP,CAAiB,UAAjB,CAA4B,IAA5B,CAAiC,MAAM,CAAC,SAAxC,CAAnB;AACA,WAAO,UAAU,CAAC,GAAD,EAAM,IAAN,CAAjB;AACD;;AAED,MAAI,aAAa,EAAjB,EAAqB;AACnB,QAAM,OAAK,GAAG,4BAA4B,EAA1C;AACA,WAAO,MAAM,CACX,OAAK,CAAC,GAAD,EAAM;AACT,MAAA,IAAI,EAAA,IADK;AAET,MAAA,MAAM,EAAE,MAFC;AAGT,MAAA,WAAW,EAAE,MAHJ;AAIT,MAAA,SAAS,EAAE;AAJF,KAAN,CADM,CAAb;AAQD;AACF","sourcesContent":["import { forget, getGlobalObject, isNativeFetch, logger, supportsFetch } from '@sentry/utils';\n\nconst global = getGlobalObject<Window>();\nlet cachedFetchImpl: FetchImpl;\n\nexport type FetchImpl = typeof fetch;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nexport function getNativeFetchImplementation(): FetchImpl {\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n\n  /* eslint-disable @typescript-eslint/unbound-method */\n\n  // Fast path to avoid DOM I/O\n  if (isNativeFetch(global.fetch)) {\n    return (cachedFetchImpl = global.fetch.bind(global));\n  }\n\n  const document = global.document;\n  let fetchImpl = global.fetch;\n  // eslint-disable-next-line deprecation/deprecation\n  if (typeof document?.createElement === `function`) {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      if (sandbox.contentWindow?.fetch) {\n        fetchImpl = sandbox.contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return (cachedFetchImpl = fetchImpl.bind(global));\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n\n/**\n * Sends sdk client report using sendBeacon or fetch as a fallback if available\n *\n * @param url report endpoint\n * @param body report payload\n */\nexport function sendReport(url: string, body: string): void {\n  const isRealNavigator = Object.prototype.toString.call(global && global.navigator) === '[object Navigator]';\n  const hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === 'function';\n\n  if (hasSendBeacon) {\n    // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch\n    const sendBeacon = global.navigator.sendBeacon.bind(global.navigator);\n    return sendBeacon(url, body);\n  }\n\n  if (supportsFetch()) {\n    const fetch = getNativeFetchImplementation();\n    return forget(\n      fetch(url, {\n        body,\n        method: 'POST',\n        credentials: 'omit',\n        keepalive: true,\n      }),\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}