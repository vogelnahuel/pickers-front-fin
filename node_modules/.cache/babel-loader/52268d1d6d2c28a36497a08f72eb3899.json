{"ast":null,"code":"import { all, call, spawn } from \"redux-saga/effects\";\nimport transactions from \"./transactions\";\nimport pickers from \"./pickers\";\nimport dashboard from \"./dashboard\";\nimport login from \"./login\";\nimport detailTransaction from \"./detailTransaction\";\nimport preliquidation from \"./preliquidation\";\nconst sagas = [...transactions, ...pickers, ...dashboard, ...login, ...detailTransaction, ...preliquidation];\nexport default function* rootSaga() {\n  yield all(sagas.map(saga => spawn(function* listenErrors() {\n    let isSyncError = false;\n\n    const resetSyncError = () => {\n      isSyncError = false;\n    };\n\n    let httpError = false;\n\n    while (true) {\n      httpError = false;\n      isSyncError = true;\n\n      try {\n        setTimeout(resetSyncError);\n        yield call(function* execSaga() {\n          yield saga;\n        });\n        console.error(\"Unexpected root saga termination. \" + \"The root sagas are supposed to be sagas that live during the whole app lifetime!\", saga);\n      } catch (error) {\n        httpError = typeof error.httpError !== \"undefined\";\n\n        if (!httpError && isSyncError) {\n          throw new Error(`${saga.name} was terminated because it threw an exception on startup.`);\n        }\n\n        yield call(handleError, error);\n      }\n\n      if (!httpError) {\n        // Para evitar que fallas infinitas bloqueen el browser...\n        // eslint-disable-next-line no-console\n        console.error(saga.name, \" will be restarted after 1 second\");\n      }\n    }\n  })));\n} // export function* handleError(error: ITypeError) {\n//   const { status } = error.response;\n//   if (status === 401) {\n//     yield put(actions.logout());\n//   }\n// }","map":{"version":3,"sources":["/home/nahuel/pickers-admin-front/src/sagas/index.ts"],"names":["all","call","spawn","transactions","pickers","dashboard","login","detailTransaction","preliquidation","sagas","rootSaga","map","saga","listenErrors","isSyncError","resetSyncError","httpError","setTimeout","execSaga","console","error","Error","name","handleError"],"mappings":"AAAA,SAASA,GAAT,EAAcC,IAAd,EAAyBC,KAAzB,QAAsC,oBAAtC;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,iBAAP,MAA8B,qBAA9B;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AAIA,MAAMC,KAAK,GAAG,CACZ,GAAGN,YADS,EAEZ,GAAGC,OAFS,EAGZ,GAAGC,SAHS,EAIZ,GAAGC,KAJS,EAKZ,GAAGC,iBALS,EAMZ,GAAGC,cANS,CAAd;AASA,eAAe,UAAUE,QAAV,GAAqB;AAClC,QAAMV,GAAG,CACPS,KAAK,CAACE,GAAN,CAAWC,IAAD,IACRV,KAAK,CAAC,UAAUW,YAAV,GAAyB;AAC7B,QAAIC,WAAW,GAAG,KAAlB;;AACA,UAAMC,cAAc,GAAG,MAAM;AAC3BD,MAAAA,WAAW,GAAG,KAAd;AACD,KAFD;;AAGA,QAAIE,SAAS,GAAG,KAAhB;;AACA,WAAO,IAAP,EAAa;AACXA,MAAAA,SAAS,GAAG,KAAZ;AACAF,MAAAA,WAAW,GAAG,IAAd;;AACA,UAAI;AACFG,QAAAA,UAAU,CAACF,cAAD,CAAV;AAEA,cAAMd,IAAI,CAAC,UAAUiB,QAAV,GAAqB;AAC9B,gBAAMN,IAAN;AACD,SAFS,CAAV;AAGAO,QAAAA,OAAO,CAACC,KAAR,CACE,uCACE,kFAFJ,EAGER,IAHF;AAKD,OAXD,CAWE,OAAOQ,KAAP,EAAmB;AACnBJ,QAAAA,SAAS,GAAG,OAAOI,KAAK,CAACJ,SAAb,KAA2B,WAAvC;;AACA,YAAI,CAACA,SAAD,IAAcF,WAAlB,EAA+B;AAC7B,gBAAM,IAAIO,KAAJ,CACH,GAAET,IAAI,CAACU,IAAK,2DADT,CAAN;AAGD;;AACD,cAAMrB,IAAI,CAACsB,WAAD,EAAcH,KAAd,CAAV;AACD;;AAED,UAAI,CAACJ,SAAL,EAAgB;AACd;AACA;AACAG,QAAAA,OAAO,CAACC,KAAR,CAAcR,IAAI,CAACU,IAAnB,EAAyB,mCAAzB;AACD;AACF;AACF,GApCI,CADP,CADO,CAAT;AAyCD,C,CAED;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { all, call, put, spawn } from \"redux-saga/effects\";\nimport transactions from \"./transactions\";\nimport pickers from \"./pickers\";\nimport dashboard from \"./dashboard\";\nimport login from \"./login\";\nimport detailTransaction from \"./detailTransaction\";\nimport preliquidation from \"./preliquidation\";\nimport { actions } from \"../reducers/login\";\nimport { Effect, ITypeError } from \"./types/types\";\n\nconst sagas = [\n  ...transactions,\n  ...pickers,\n  ...dashboard,\n  ...login,\n  ...detailTransaction,\n  ...preliquidation\n];\n\nexport default function* rootSaga() {\n  yield all(\n    sagas.map((saga: Effect) =>\n      spawn(function* listenErrors() {\n        let isSyncError = false;\n        const resetSyncError = () => {\n          isSyncError = false;\n        };\n        let httpError = false;\n        while (true) {\n          httpError = false;\n          isSyncError = true;\n          try {\n            setTimeout(resetSyncError);\n\n            yield call(function* execSaga() {\n              yield saga;\n            });\n            console.error(\n              \"Unexpected root saga termination. \" +\n                \"The root sagas are supposed to be sagas that live during the whole app lifetime!\",\n              saga\n            );\n          } catch (error: any) {\n            httpError = typeof error.httpError !== \"undefined\";\n            if (!httpError && isSyncError) {\n              throw new Error(\n                `${saga.name} was terminated because it threw an exception on startup.`\n              );\n            }\n            yield call(handleError, error);\n          }\n\n          if (!httpError) {\n            // Para evitar que fallas infinitas bloqueen el browser...\n            // eslint-disable-next-line no-console\n            console.error(saga.name, \" will be restarted after 1 second\");\n          }\n        }\n      })\n    )\n  );\n}\n\n// export function* handleError(error: ITypeError) {\n//   const { status } = error.response;\n//   if (status === 401) {\n//     yield put(actions.logout());\n//   }\n// }\n"]},"metadata":{},"sourceType":"module"}