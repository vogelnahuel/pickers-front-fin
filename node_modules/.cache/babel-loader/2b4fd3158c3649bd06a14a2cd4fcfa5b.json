{"ast":null,"code":"import { RequestSessionStatus } from '@sentry/types';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\nimport { getCurrentHub } from './hub';\n/**\n * @inheritdoc\n */\n\nvar SessionFlusher =\n/** @class */\nfunction () {\n  function SessionFlusher(transport, attrs) {\n    var _this = this;\n\n    this.flushTimeout = 60;\n    this._pendingAggregates = {};\n    this._isEnabled = true;\n    this._transport = transport; // Call to setInterval, so that flush is called every 60 seconds\n\n    this._intervalId = setInterval(function () {\n      return _this.flush();\n    }, this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n  /** Sends session aggregates to Transport */\n\n\n  SessionFlusher.prototype.sendSessionAggregates = function (sessionAggregates) {\n    if (!this._transport.sendSession) {\n      logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n\n    void this._transport.sendSession(sessionAggregates).then(null, function (reason) {\n      logger.error(\"Error while sending session: \" + reason);\n    });\n  };\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n\n\n  SessionFlusher.prototype.flush = function () {\n    var sessionAggregates = this.getSessionAggregates();\n\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  };\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n\n\n  SessionFlusher.prototype.getSessionAggregates = function () {\n    var _this = this;\n\n    var aggregates = Object.keys(this._pendingAggregates).map(function (key) {\n      return _this._pendingAggregates[parseInt(key)];\n    });\n    var sessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates: aggregates\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  };\n  /** JSDoc */\n\n\n  SessionFlusher.prototype.close = function () {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  };\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n\n\n  SessionFlusher.prototype.incrementSessionStatusCount = function () {\n    var _a, _b;\n\n    if (!this._isEnabled) {\n      return;\n    }\n\n    var scope = getCurrentHub().getScope();\n    var requestSession = (_a = scope) === null || _a === void 0 ? void 0 : _a.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date()); // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n\n\n      (_b = scope) === null || _b === void 0 ? void 0 : _b.setRequestSession(undefined);\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  };\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n\n\n  SessionFlusher.prototype._incrementSessionStatusCount = function (status, date) {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    var sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {}; // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n\n    var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case RequestSessionStatus.Errored:\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n\n      case RequestSessionStatus.Ok:\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n\n      case RequestSessionStatus.Crashed:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  };\n\n  return SessionFlusher;\n}();\n\nexport { SessionFlusher };","map":{"version":3,"sources":["../src/sessionflusher.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AggregationCounts,\n  RequestSessionStatus,\n  SessionAggregates,\n  SessionFlusherLike,\n  Transport,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\n\nimport { getCurrentHub } from './hub';\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number = 60;\n  private _pendingAggregates: Record<number, AggregationCounts> = {};\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean = true;\n  private _transport: Transport;\n\n  public constructor(transport: Transport, attrs: ReleaseHealthAttributes) {\n    this._transport = transport;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Sends session aggregates to Transport */\n  public sendSessionAggregates(sessionAggregates: SessionAggregates): void {\n    if (!this._transport.sendSession) {\n      logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n    void this._transport.sendSession(sessionAggregates).then(null, reason => {\n      logger.error(`Error while sending session: ${reason}`);\n    });\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope?.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      scope?.setRequestSession(undefined);\n\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case RequestSessionStatus.Errored:\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case RequestSessionStatus.Ok:\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      case RequestSessionStatus.Crashed:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}